* current work
* [~] issues
** [~] system
*** init_data sends all data - should limit to "player_any"
*** socket_t routines should have a timeout
*** weird that solar systems aren't automatically searched when colonized?
*** Ships validate their action using target information that the player can't see
*** look through all copy constructors to make sure they explicitly call parents
** [~] gui 
*** game objects handle event before (non query window) interface widgets
    E.g. quit button or right panel
*** [?] only allow command action if *available* ships support it
*** Clicking interface response button also triggers click on minimap
*** sfg window does not resize on sfml window resize
*** command selectors drawn on top of each other
*** simulation step hangs on key escape abort game
    This was when client 1 aborts at frame -1, while client 2 is still
    in choice step. Server exits with error 'disconnect' and other
    client gets segfault. Perhaps the server failed to receive the
    leave game request from client 1 while it was waiting for the
    choice from client 2.
*** [redesign] client allows multiple development choices - server does not
* system design ideas
** make ships have to go around territories and neutral solars
** generalize game_settings::starting_fleet to some "starting bonus" 
** add expansion limitations e.g. nr of fleets and solar distance penalty
** make detection stat determine which object stats are seen by client
** add a command buffer so commands reach entities with distance based delay
** add terrain
   For starters: impassable areas. This requires fleets to do path
   finding.
** make ship cost scale with upgrades
** allow "fortification" so units can block other units and hold a position?
** add trigger system for e.g. upgrades, techs and solar facilities
*** hm_t<string, function> on_interaction (and prevent_interaction)
*** on_takeoff (for e.g. freighter ship)
*** extra_solar_dynamics
** ?add a "dynamic data" hash map to game object
   For stuff like "has cargo x", "is jammed", "was scanned by player i" etc.

   No particular reason to not put this in normal class members?
** add a vision map, build in client on reload_data
** [?] make angular acceleration an attribute
** [?] consider letting fleet suggestion contain an angle
** [?] try making a memcpy based serialization
   Maybe classes containing pointers can have a serial subclass?
* tweaks and fixes
** gui
*** solar radius too large
*** client::game::entity_at should respect zoom level
*** protect from spacebar immediately after simulation is finished
*** clicking ship label in target_gui should select/deselect all 
*** show ship health by marking ship vertices red
*** allow double-clicking ship to select all of same type
*** allow dragging waypoints
*** name and indicators for solars so you can tell them apart
** system
*** make fleet move at below speed limit so ships can catch up
*** decrease likelihood of finding treasure
*** ships should stop when they hit converge on a waypoint
* optimization
** drawing client side stuff starts taking time
   Consider not drawing complete universe on minimap
** fix grid tree so make_split takes less time
   Consider using simple linear split nodes, this will make it easier
   splitting between leaves.
** reduce sent data 
*** using an instruction based model
   With instructions for updating and removing existing entities. Let
   client request when new entities are needed. Then the server won't
   need to copy all entities and rebuild the grid, and the client also
   won't need to copy entities.

   This will require every function which modifies an entity to also
   register this in an update map, or, alternatively, a central
   "modify_entity" access point for this purpose. Reasonably, this
   could be designed by making all entity properties be part of a hash
   map. It will also require the client to list and ask for required
   entities each frame.

   Might cause so much extra work on server + extra calls that it
   slows down the whole process, plus it's quite a lot of work.
*** using compression
    An easier alternative would be to gather all frames in the packet
    and then compress it before sending, by inheriting
    sf::Packet::on[Send|Receive]().

    On client, first show computation progress and then show dl
    progress - check if sf::Packet::getDataSize() can be used for this
    purpose.
* content ideas
** [J?] scouts are possibly too lousy at fighting
** [J] add some tech/facility for pop crowd, ecology, water and space
* to be tested
** untested functionality
*** new trade interaction
*** new colonize interaction
** confirm bugs
*** [J?] "space_status: used more than space" reached after developing facility
*** [J?] interaction space combat should default to aggresive policy
*** [J?] add/fix bombard animation
*** [J?] progress bar goes behind right panel
*** [J?] upgraded fighters have too much health vs damage
*** [J?] sector boosts apply exponentially with level and should be lower
*** [J?] log panel grows sideways off screen, info panel follows
*** [J?] state of water, space and ecology of new solars is too random
*** [J?] solars run out of space after building some stuff
    Make facilities not use more space per level. Add facility
    attributes "provides space" and "provides water".
*** [J?] deleting command does not cause command to be removed on server
*** [J?] mass-based upgrade "warp drive" not applied to any ships
*** [J?] right click with selected ships creates waypoint with no incident commands
*** [J?] apply sector boost from research in solar
*** explosions are too long
** analyze
*** [?] solars dissapear from sight
*** [!confirm?] fleets don't seem to get cleared from client choice
   Client seems to remove fleets when instructed, and c.fleets is
   cleared. Server clears all fleets during pre step, and removes old
   fleets when applying commands.
*** ?? solar choice not saved when opening development gui
*** client created fleets can't be click-selected
* remember
** when updating a struct/class, also update serialization
* git pending
* fixed
** [J] better combat "feel"
    o [J?] slow down when entering combat
    o [J] make distance part of accuracy check and apply it in ship::move when checking shootability
    o [J?] increased angular rotational acceleration for large ships
    o [J?] increase damage / health ratio
    o [J?] increase rate of fire
    o [J] Corsairs don't beat fighters - set load time to 0 and increase damage and accuracy
** [J] split game_settings into parent classes client_settings and server_settings
** [J] apply upgrades in test_space_combat
** [J] too much randomness in testing - segfault in boost::random::mersenne_twister_engine
** [J] warning: non-diverse leaves in grid::node::make_split!
** [J] window freezes while waiting for other clients to connect
    Since wait_for_it() doesn't start window loop unless desktop is
    initialized.
** [J] implement new client communication structure
*** [J] Find a thread safe structure for accepting clients
    Consider that hm_t::operator[] is not thread safe, while at the
    same time handle_sigint can't wait for dispatch_client before
    setting socket_t::tc_stop.

*** [J] Server
    safe_game_access(gid) {
      o *lock* game ring
      o [get|create] game
      o *unlock* game ring
      o return game
    }

    safe_delete(gid) {
      o *lock* game ring
      o cleanup and erase game gid
      o *unlock* game ring
    }

    safe_game_count() {
      o *lock* game ring
      o result = games.count()
      o *unlock* game ring
    }

    safe_state(gid) {
      return safe_game_access(gid).state
    }
**** game_dispatcher
     while (server_status == run) {
       o *lock* game ring
       for (auto g : games) {
         if (g ready to launch) thread dispatch_game(g.id)
       }
       o *unlock* game ring
       o sleep a bit
     }
***** dispatch_game gid: only runs on game in init state
       // at this point, no more clients will pass the "can join game"
       // condition

       o game = safe_game_access(gid)
       o *lock* game 
       o get list of clients
       o *unlock* game 
       o join all client wait_for_game threads
       o game_handler.run()
       o disconnect clients
       o *lock* game 
       o set game state to complete
       o *unlock* game 
**** Listener
***** dispatch_client (add timeout for introduction protocol)
      o check server status
      o client >> gid >> settings >> name
      o game = safe_game_access(gid)
      o *lock* game
      o read game state
      o can_join = game state == init and game not full
      if (can_join) {
        o write to game: add client and (if new) settings
	o package = ok + id
      } else {
        o package = not ok
      }
      o *unlock* game gid
      o client << package
      o if (can_join) thread wait_for_game
****** wait_for_game gid
       while (safe_state(gid) == init) {
         c -> check_protocol(load_init, standby)
       }
       o if (safe_state(gid) == running) set client state to running
**** Signal Handler
     o set server status to stop
     o *lock* game ring
     for each game {
       *lock* game
       set status to stop
       *unlock* game
     }
     o *unlock* game ring
     o while (safe_game_count()) {
       for each game gid: if safe_state(gid) == complete: safe_delete(gid)
       sleep
     } 
*** [J] Mixed thread io on server
    *handle_sigint* sets thread_com to tc_stop, then *cleanup_clients*
    waits for thread_com == tc_complete.

    A) If the game has not been started, thread_com will never be set
    to tc_complete. *cleanup_clients* must check for games that have
    waiting clients but have not been started.

    B) Thread safety (low risk): if *handle_sigint* sets thread_com to tc_stop
    after it was set to tc_complete at end of dispatch_game,
    *cleanup_clients* will never complete.

    Instead, use separate input and output com variables; this should
    solve both problems.
*** [J] unexpected protocol exception using protocol any
*** [J?] client simulation step ends when all frames are loaded
*** [J] try to create a general structure for running com-threads
    Something along the lines of a function that takes a communication
    task and callbacks on_complete and on_fail, but also integrates
    with the window_loop somehow, and also works with multiple clients
    and datasets on the server side.
*** [J] client::query should take two com parameters: tr and tc
    They should use the socket_t::tc_* protocol. tc should be passed
    on to socket -> thread_com.
*** [J] window loop should take a parameter lc and return a response lr
*** [J] event handlers should set tc = tc_stop on abort event
*** [J] body callbacks should set lc = query_abort if tr == tc_stop
*** [J] client:::query should only call [send|receive]_packet once
** [J?] solars don't show player colors
** [J?] command_gui should not show during simulation!
   Add some kind of phase tracker variable
** [J] wrap all output in macro #ifdefined VERBOSE
** [J] terribly slow run on server, though not using CPU (network?)
** [J] don't show animations when loading data in pre/choice-step
** [J] add random animation-delay based on sub-frames (consistent for animation pairs)
** [J] make animation time parameter respect sub-frames
** [J] at start/end of ship path, interpolate around an inner point instead
** [J] bind animations to entities if available
** [J] Issue with "seen" being unset
   Solution: references in passed frames had been *deleted*.

   For some reason, the "seen" property of ships in passed data frames
   is unset, causing them to be ignored by the position kernel.
** [J] find suitable kernel for smooth ship visualization
** [J] non-active entities should not be labeled as seen by client
** [J] figure out why setting seen = is_active() for selector causes segfault
   Caused by attempting to dynamic cast an entity_selector* to a
   specific_selector<ship>* - presumably this requires some reference
   to the other parent class.
** using reduced granularity
    This requires the client to interpolate between frames.
** [J] make server handle signals instead of looping over true
** [J] make server clean up old games on completion
** [J] to big early advantage finding scouts in treasure, as they can search
** allow controls and stuff during simulation
** zoom in should target mouse point
** allow zoom, show entity info etc during simulation
** show accumulated research
** autofill commands with only those units which support the action
** research completes too fast
** "make your choice" and progress bar too low
** show ship stats in ship hover info
** [J] respect mouse position on zoom
** [J] waypoint, command and fleet selectors should invert zoom
** [J] No research progress shown
    Server does pool research points.
** [!] distinguish between interactions and auras (e.g. hive support)
   At the moment, non-targeted interactions are not applied at all
** [J] new better universe builder, possibly generate while exploring
** [J] possibility to find "treasures" when discovering new solar systems
   Combined with a new detection level stat of some kind.
** [J] technology still researches instantly, even when sector research is not active
** [J] extend_universe pushes solars into already discovered area
** [J] guarantee good nsolar in starting area
** [J] solars too tightly packed
** [J] zoom still doesn't run during simulation
** [J] make solar dynamics use sectors medicine and ecology
** [J] treasure found at solars that the client can't see
** [J] implement find_treasure
** hover info moves further down each time it's updated
** [J?] trade actions can't swap fleet action 
   since this prevents other ships in fleet from trading. Somewhat
   solved by default assigning one ship to special actions.
** [J] selecting in development_gui resets scroll
** facilities build to 100% but never complete
** [J?] add a list of animations to send to client rather than add explosion on ship removal
** [J?] add a battle-log to send to client
** [J] memory leak
   Forgot to clear buffer ship::local_all before adding new data.

   Note that entity_package::clear_entities does successfully
   deallocate, shown in test_memory().

   Memory loss triggered from game_handler.cpp: 29. Note that memory
   usage rises before distribute_frames starts working.

   valgrind says there is no memory leak in my code (just two small
   ones in *ld* and *esets*). However, almost all memory usage arises
   from the following location:

->42.95% (12,759,264B) 0x40FF62: st3::ship::operator=(st3::ship const&) (ship.h:18)
-> ->42.95% (12,759,264B) 0x4975EF: st3::ship::copy_from(st3::ship const&) (ship.cpp:561)
->   ->42.95% (12,759,264B) 0x492050: st3::ship::ship(st3::ship const&) (ship.cpp:137)
->     ->42.95% (12,759,264B) 0x496DC3: st3::ship::clone_impl() (ship.cpp:497)
->       ->42.95% (12,759,264B) 0x48FF6D: st3::game_object::clone() (game_object.cpp:46)
->         ->42.95% (12,759,264B) 0x40BBAF: st3::entity_package::copy_from(st3::game_data const&) (game_data.cpp:611)
->           ->42.95% (12,759,264B) 0x43AA44: simulation_step(st3::server::com&, st3::game_data&) (game_handler.cpp:29)
->           -> ->42.95% (12,759,264B) 0x43B550: st3::server::game_handler(st3::server::com&, st3::game_data&) (game_handler.cpp:113)
->           ->   ->42.95% (12,759,264B) 0x438FBC: main (server.cpp:34)


   Seemed fixed by clearing entity_grid at pre_step, but unfixed when
   inserting entities after clearing grid.

   Check that old fleets get cleared and that landed ships are not
   hiding at origin causing tree depth.

   Memory seems to rize in chunks at end/beginning of round.
** [J] log research and facility completion
** [J] show current research choice and progress in gui
** [J] available developments should also be in a scroll-window
** [J] priority buttons unresponsive to first right click
** [J] available developments' build button should be bottom aligned
** [J] development req list is not left-aligned
** [J] build log in client_game and add widget
** [J] redesign solar_gui
*** [J] add boosts in solar::developed()
*** [J] add button for showing research gui
*** [J] colonizer should carry 1000 ppl
*** [J] colonizer gets 0 progress
*** [J] sol -> developed() have name == "" in solar_gui
*** [J] find out why solar::development costs become inf on client side
*** [J] add development::node::progress replacing research and development points
*** [J] add parameter progress to graphics::selector_card 
*** [J] mining: automatically prioritize what is available inversely to storage
*** [J] add research_gui: wrap new development_gui with ok/cancel + progress
*** [J] use solar_selector::choice_data instead of desktop -> response.solar_choices
*** [J] make client::game::build_chioce use choice data from solar selectors
*** [J] three tabs: sectors, development, military
*** [J] sectors: remove template buttons
*** [J] remove research::solar_template_table
*** [J] allow selecting multiple templates, multiple ships but only one dev
*** [J?] development choice is forgotten by opening and closing solar gui
*** [J?] solar gui defaults to zeros even though choice_data is sent
** [J?] landed on negative development points after completing expansion factories
** [J] add "build" button on facilities in solar_gui
** [J] command selectors should update their position on each reload_data
   Maybe they are? They jump in direction of command...
** [J?] fleet suggests summon | travel when arriving at destination solar
** [J?] ships should set speed = 0 on liftoff
** [J?] warp drive way too fast
** [J?] mouse scroll should zoom
** new modified ship stats
** [J?] tag ships as e.g. small, large, bio, mech etc.
    This will allow techs applying upgrades to ships by type
** [J?] add ship attributes stealth, detection, regen and shield
** ships remain selected after fleet is created
** [J?] form fleet with F doesn't work
** [J?] ship upgrades e.g. warp drive do not respect e.g. !small for scout
** [J?] show unmet requirements for development::nodes with no dependencies
** [J] command selector policies uninitialized after reload
    Happened after fleet was idle at waypoint through round
** [J] reset_qw is called from event handlers, possibly breaking event loop
** [J] no delete button in command_gui
** [J] tech requirements list floods window
   Make scroll window?
** [J] command_gui: sfg::Image -> SetImage causes meshed image
   Consider making image with background color?
** [J] command_gui throws bad_weak_ptr
   In event handler, after moving ship button to tab_allocated

   Caused by removing a widget while in the parent widget's event loop
** [J] command_gui ship buttons cover complete table
** [J] graphics::ship_button drawn on weird angle
** [J] main_interface::reset_qw() does not clear command_gui radio buttons
** [J] fleets should try to set scatter point towards owned solar
** [J] fleets should try not to change the scatter point
** [J] fleets should suggest travel instead of scatter if target direction is free
** [J] remake command gui to handle fleet policies
** [J] after passing waypoint, fleet becomes idle
** [J] make reassignment in relocate_ships pass on origin
** [J] idle fleet keeps moving and therefore summons ships to keep moving
** [J] ship speed is not checked for max
** [J] replace references to ship stats
** [J] implement use of mass stat for detection, accuracy and graphics scale
** [J] implement use of evasion stat to counter accuracy
** [J] implement remaining ship_stats functions
** [J] remove physical_object::interact, call interactions in move phase
** [J] make solar call interactions in move phase
** [J] make fleet analytics use ship size to determine enemy strength
** [J] make fleet::suggest use enemy strength factor
** [J] implement ship::move using fleet::suggest
** [J] make fleet generate scatter_target
** [J] make client choice contain fleet policy
** [J] update ship data with regard to accuracy/mass/evasion interaction
** [J] build entity_seen_by matrix in game_data for use in search_targets
** solar development tree
   Just something a little bit more fun than "expansion[i]", e.g. move
   turrets here.
** [J] upgrade nano scout does not seem to reduce enemy sight range
** [J] make solars indicate when they can build
** [J] check that turrets apply level
** [J] setting a solar template should preserve the development choice
** [J] continue splitting up interfaces
** [J] make new "development" interface that can be used for research and facilities
** [J] allow selecting not to develop solar facilities
** add development::node::list_requirements + gui
** float priority values in solar gui can get negative value
** show fleet selector and dim vision radius
** fixed a bug where facility copy constructor didn't call development::node::node
** solar_selector doesn't seem to receive proper research_level pointer
** [J?] go through solar data
** [J] update serialization with development::node and subclasses
** [J] add development tree to makefile
** somewhere, solar development["military"] is being initialized
** make turrets hit different targets
** give ships reduced accuracy when not firing forwards
** ships built way to fast
** tech researched to fast
** template for culture growth should have more culture
** [J] development points aren't spent
** [J] set research points to same speed as development
** [J] client submitted invalid development: radar tower
** [J] too high production of development points
** [J] ships are drawn in color cnose only
** [J] infobox off screen
** [J] make solars show research and development points + level
** [J] solar development not paying resources
** [J?] fix solar gui to fit new solar choice
** [J?] new structure using JSON files for upgrades, ships and research
*** [J?] implement development_tree::available
*** [J?] look over serialization of all new types, eg newly added stuff in ship_stats
** [J] rewrite json access loops using special MemberBegin and Begin
** [J] write solar_data.json
** [J] replace ship_allocation with lookup keys in ship::table
    This includes adding graphics info to ship_data.json?
** [J] implement solar::development_tree::facility_tree()
** [J] write game_data::confirm_data that loads data and validates references
** [J] fix references to e.g. research::data::tree
** [J] ship::ship(ship_stats) must assign base_stats
** [J] data loader functions are accumulating sets e.g. upgrades
** [J] fill out ship_stats constructor
** moved target selection to specific class
** create a frame structure
   Introduced class entity_package parent to game_data, with entities
   and remove_entities. Then the distribution frame buffer can copy
   entities only from the game_data object, and the client
   distribution frame buffer can limit_to using only entities. This
   will require entity_package to limit_to without deallocating.

   Declared but not instantiated.
** template for mining that sets nessecary amount
** add explosions
** allow client to control/restructure fleets
*** allow ships to have no fleet
*** clear fleets with no command on client side
*** allow client to create fleets from ship clusters
** when client-created fleet is returned to client, com.source is empty
** ships aren't drawn because is_landed is not serialized
** make colonizers consume people
** commands for fleets with id "owned" by server don't pass validation
** test freighter ships
** fixed handling of partial sending of sf::Package
** added command origin for use in trade interaction
** fixed: ship production flipped out (uninitialized ship cost)
** [J?] introduce physical_game_object for ship and solar
   This way, we can limit targeting to physical entities, and avoid
   the hassle with tracking fleets when they split. Also, non-physical
   entity classes don't need to implement interaction related
   functionality. Also, client can reconstruct non-physical entities
   at will.
** [J?] make all interactions be buffered and then evaluated in post phase (remove solar post phase stuff)
** [J?] make landing be an interaction
** military template needs to respect ship build dependencies
** targeting a waypoint should not create a new waypoint
** float hp for ships
** selecting research should add it to "researched"
** research
*** [J] define choice::c_research
*** [J] research::data constructor
*** [J] research::data + choice::c_research serialization
*** [J] research choice gui
** Invalid (scrambled) research choice submitted
   Temp name variable was passed byref to button handler
** upgrade / interaction / game object makeover
*** [J] solar choice for invalid player after conquering solar
*** [J] make fleet selectors for enemy fleets
*** [J] ships should auto-engage
*** [J] newly colonized solars' dynamics generate NaN in all fields
*** [J] idle shouldn't be an action
*** [J] join fleet shouldn't be an action - use waypoints
*** [J] ships shouldn't be selectable
*** [J] trouble selecting things under non-owned things
*** [J] Colonize and join fleet commands are abandoned
*** [J] solar choice resets
*** [J] Need to remove "unseen" units when the area becomes seen
*** [J] insert + make_split loop in grid_tree causes segfault
    After giving a waypoint with some units an empty command "space combat"

    Fixed make_split criteria using median instead of mean
*** [J] distribute ships: way too spread out
*** [J] fleet selector: way to big
*** [J] Segfault 
    Apparently had to do with fleets loosing sight of targets and
    calling get_entity and stuff (and possibly passing shared_ptr to a
    temporary lambda function), however the main lesson is that
    unhandled exceptions from threads are not displayed properly in
    the debugger.

    After finding an enemy ship in game_data::search_targets(), at game_data.cpp:296

    Switched back to normal pointers, which helped in a simplified
    case, but now there is instead a sigabrt in the thread destructor
    of distribute_frames thread, right after ship fire.

    Consider deleting game_data copy constructor and only doing
    explicit assignment, possibly also explicit destruction.
*** [J] Figure out why server sends old waypoints in [prestep?]
*** [J] Figure out why commands dissapear 
    ... from waypoints (or only from selectors) without passing the
    trigger point

    Command selectors were not being rebuilt for waypoints
*** [J] change identifier::some_class_id to the_class::class_id
*** [J] introduce game object base class
**** [J] created base class header
**** [J] made game entity classes inherit game object
**** [J] inherit pre/post phase functions in game object classes
**** [J] define ptr classes (grid::tree should have a unique ptr?) and create functions
**** [J] change to virtual inheritance of game_object so entity_selector subclasses don't get duplicate inheritance
**** [J] add new files in build system: game_object, ship, waypoint
**** [J] go through game_data.cpp and move code to object classes
**** [J] implement game object class functions
**** [J] add fleet action functions e.g. land 
**** [J] the fleet is responsible for tracking action validity when target status changes
**** [J] fleets need to update data in pre phase and remember to update target position
**** [J] add an interaction class declaration
**** [J] implement the interaction class
**** decide how to distinguish between owned and non-owned target conditions
*** [J] add an upgrade class
*** [J] let ships have reference to upgrades instead of interactions
*** [J] let upgrades have interactions and stat-mods
*** [J] let upgrades define exclusivity for certain terms
*** [J] let ships have a compile_stats function, base and current stats
*** [J] let ships have a compile_interactions function
*** [J] let combat interactions use a ship::receive_damage function
*** [J] for each ship, check each interaction target condition for each target
*** [J] rebuild ship templates so they apply upgrades
*** [J] let the ship increment function be responsible for updating load time
    the interaction functions will be responsible for activating load time
*** [J] consider introducing a game_data::find_targets
   Conditioned on a ship::target_condition and a radius
*** [J] add fleet action definitions
*** [J] finish implementing new serialization/deserialization
*** [J] fix client game reloading of waypoints
*** [J] implement client game deserialize of game data
*** [J] remove game_data deserialize operator
*** let upgrades have an optional tick function
*** let upgrades have description 
*** [J] let upgrades define ship class exclusivity conditions
** invalid? allowed allocation from fleet and waypoint in parallel
    FIX: fleet selectors at waypoints initially have a command
    targeting the waypoint
** guaranteed_cast template for selectors instantiated in utility.cpp
**** needed because definition must be avilable
**** problematic because then utility depends on selector and graphics
**** FIX: moved to separate instantiation file
** BUG: client recieves distorted game object data
**** game_object component correct so far as specific_selector::create
**** for solar: c_military and beyond, data is scrambled
**** when displayed, all data seems corrupted
** BUG: ship function recieve_damage() is not serialized
    Need to externalize these functions.
** moved selector cast template instantiation back to utility
** implemented specific_selector<ship>
** implemented specific selector create function
** ship vision
** utility::random_int
** moved deserialize to com_client to avoid excessive server deps
** make minimap clickable
** get rid of sfml sub repo?
** hover info should depend on ownership
** exit query should listen to escape/return key events
** c_solar::template_map: multiple calls to empty_choice() crashes
    After second call, returned choice is *really* empty.
** military template sucks
** solar gui has transparent background
** no info about available resources in solar gui
** fixed bug: ship not removed after colonize before ship_solar_int
** fixed bug: com_client::query catches winner message
** fix ship swarm movement
** end game status not displayed
** After fixing leave game, server says invalid query on simulation
** lacking proper leave game functionality
** why does sending frames take so long?
   turns out this is game_data.increment()
** go through game_data::increment
** ships not showing on client since sockets redesign
** server socket mess
*** client_t must deallocate it's TcpSocket on dtor
    ... so that check_protocol can remove dc clients

    ... and server main must not deallocate them

    Perhaps move listening/accepting to server::com?

    Perhaps inherit sf::TcpSocket?
*** server::com needs a method 'bool has_multiple_clients()'
    To be run after check_protocol
*** check for protocol::leave in simulation step as well
** projectile graphics object
** sub divide solar dynamics so components are accessible from gui
** consider moving sub window classes to main window build routine
   so they can access tooltip etc.
** solar system stability tests
**** parallel cost subtractions
** turrets do no damage? take no damage?
    look over solar combat routines
** solar choice has negative values in solar tick
    possibly fixed by initializing summation var in allocation::count

    possibly fixed by limiting water usage checks to expansion
    sectors
** crowding death goes to NaN
** notes on some bugs
** fixes to solar dynamics resource payments
** ship build run away (increase cost/time?)
** bad default solar choice (add templates?)
**** added choice templates
**** how should choice template buttons trigger allocation button update?
     consider connecting a custom signal?
     remember to set sub window to build_info()
** sector expansion happens without resources
** added basic solar info
** added listening to proceed button
** digits are ugly
** clicking a solar (sub) query priority button causes segfault
    fix: used a normal pointer to the button
    since introduction of referenced buttons in event handlers
** clicking in solar gui also triggers game object event handler
** accepting solar gui does not destroy priority buttons
    fixed: byref widgets to event handlers
    ... nor does it destroy sub window buttons
    maybe stuck in event functions?
** frame rate is to high
** simulation step is not drawn
    Solved: fixed a bug where the simulation step event handler forgot
    to return a value.
** interface is drawn on mini-map^^
    Solved: note: sfgui draws on the latest view which was drawn upon,
    not on the current view!
** generalized client game window loops to a function
** adding a Box::Ptr in a Window fails internally (graphics.cpp: 209)
    error: bad_weak_ptr
    std::shared_ptr (count 4, weak 2)

    Probably caused by that methods are not called through a shared
    pointer in the constructor? Move constructor to create method...
** check that serializations still match content
** check choice sub allocation for military
** check that all initialize-functions are called
** figure out why file-global allocation sub classes init empty
    probably the keywords data they use is not initialized?
    moved to initializers
** c_solar::normalize uses countable_allocation::normalize
** fixed compile step errors
** [done] consider adding named string constants for sub sectors etc.
** fix: serialization templates prefer general over specific
** made specific allocation classes
** [done] add a turret class
** [done] implement vectorised allocation templates in graphics.cpp
** [done] apply updated solar (choice) structure in solar_tick
** figure out how to limit sub sector priority
** [done] default values for solar choice
** moved solar::choice_t to choice.h
** [done] finish cost.cpp
** [done] client_game::build_choice should link game object events to interface objects, e.g. solar clicked
** selector queue cycling
** targui scales with zoom
** comgui does not show action
** targui remembers selected entities
** targui text does not fit width
** [done] add to command: action (from above options)
** [done] add command::action to command::operator ==
** [done] add queue_level to command_selector
** [done] add queue_level checking to command_at
** [done] replace entity_at with entities_at
** [done] replace right click event handler with target option gui
** [done] implement command action in game_data::increment
** display victor
** client generated solar choice for other player's solar
   maybe happened after the solar was conquered?
   
   probably fixed: removing choices for non-owned solars in
   client::game::reload_data
** send victor to client on game completion
** solar gui does not draw buttons in resized window
** sending colonizer ships spends population
** template selector is ugly
** colonisation/transport ships
    and make some solars without defense
** incorrect population increment shown
** should respond to return/escape keys
** does not terminate on window close event
** minimap drawn over comgui
** [low priority] minimap bounding box drawn incorrectly after window resize
** defense build rates need to be checked
** fleets follow targets that leave sight
   check range of sight in update fleet data?
** fleets follow last assigned in split
** templates and feedback in solar gui
    show per round increments in overview
** [fixed?] solar gui lists increments per unit time
   game settings stores round length in ticks
** moved dt from game_data to game_settings to avoid duplicate in client_game
** removed entity_selector::allocated_ships
** setting up autotools
   aclocal generates aclocal.m4
   automake --add-missing uses configure.ac, aclocal.m3 and Makefile.am to build Makefile.in
   autoconf uses configure.ac to build configure
   configure uses Makefile.in to build Makefile
** [low priority] command_gui scales with zoom
** add template selector to gui
** implement templates in solar_gui.cpp
** faster initial expansion
** [fixed for single fleet relocation] fleet targets are lost on split (new id)
** fixed: orders targeting unseen targets disappear
   also targeting fleets that leave sight
** fixed a bug where bombarded solars get negative defense/population
** add attribute bool entity_selector.seen
    store entity selectors, but unset seen each round. Show non-seen
    entities as semi-transparent, non-interactive.
** fixed: player colors difficult to distinguish
** fixed: waypoints not dissapearing (had erased waypoint removal)
** fleets sent to waypoint remain idle
** fog of war
*** [done] give ships attribute sfloat vision
*** [done] give fleets attribute sfloat vision
*** [done] add fleet.vision to serialisation
*** [done] update fleet.vision in update_fleet_data()
*** [done] give solars attribute vision
*** send limited game data objects to client
     a fleet or solar is seen if it is owned or within vision range of
     an owned fleet or solar.
** research should influence ships
** fixed a bug where solar ships were not sent to client
** gave ships vision
** fixed a bug where waypoints were cleared between choice evaluations
** added research to solar gui
** added research influence in ship constructor
** added research to serialization
** solar choice interface
** replaced waypoint.landed_ships with checking fleet idle target
** added minimap, fixed text scale and position
** tempfix for: fleet growth goes negative
** fixed: idle fleet sent to waypoint remained idle
** fixed: waypoint removed though having landed ships
** research pooling
** better game round phase indicators
** command_gui should sort ships by type
** added ship class sub tables in command_gui
** fixed: ships that have left or died remain listed at waypoint
** fixed: fleet evaluation order impacted battle result
** added an entity_selector -> queue_level (select order queue)
** fixed: comgui does not close after choice step
** fixed: fleet speed limit = min(ship.speed)
** fixed: prevented creation of circular graphs
** fixed: when client deletes command + wp, server reinserts wp
** fixed: server removes waypoints with landed ships
** fixed: ships fire in order of fleet, unfair
** fixed: when targeting a fleet, server crashes because id changes
** fixed: fleet idle target
   when arriving to waypoint or client unsets command
   (waypoints now store landed ships)
** fixed: waypoint graph reconstruction
** fixed: command receive printout
** fixed: waypoints created when no sources selected
** fixed: fleet radius can decrease indefinitely
   the radius must be large enough so the player can select the fleet
** graphics::draw_ship different types and param scale
** discovered some new bugs, see notes.org
** fixed: waypoint pending_commands not updated
   for some odd reason fixed by looping over 
   for(k,v in all_wp) waypoints[k] = v;
   instead of assigning
   waypoints.insert(all_wp.begin(), all_wp.end());
** fixed: server seems to list waypoints multiple times
   caused by multiple \n in id?
   note that clients resend old waypoints!
** fixed: commands on waypoints are not handled in choice phase
** fixed: waypoints targeted by waypoints are deleted
** fixed: fleet does not show radius after waypoint trigger
   and can't be selected
** fixed: client rectangle upwards select does not work
** fixed: fleet position seems to be off
** added ship scale to draw routine so ships are larger in command gui
** fixed recursive ship increment/decrement through waypoints
** fixed a bug where remove command deleted the wrong entity
** command distance checker sees past end points
** best way to add external dependencies
   added sub directories to make
   consider linking to their git repos?
** when giving multiple fleet commands, all ships are assigned
** added command_gui
** added SFML and TGUI as submodules in external/src
   make will build them in external
** simplified ship drawing selection in game::draw_universe
** window transforms should remain to next round
** add waypoint to game_data serialization
** fix waypoint id check in game_data::target_position
** fixed relocate ships setting new ship fleet id
** add waypoint objects
    so that: 
    o commands don't need child commands
    o multiple fleets can meet at a waypoint
    o commands aren't source/target entities
** commands should not be targets
** solar system
** write selector::get_ships, remove selector::get_quantity
** upgrade to sfml2.2 
   to get window::hasFocus()
   to enable building ~/code/include/TGUI-0.6.7
   (note that tgui 0.6.6 should work with sfml2.0)
   https://tgui.eu/
** build and test ~/code/include/TGUI-0.6.7
** why is client receiving sig abort on disconnect? thread-related?
   exit was called in query thread
** game_data::increment (ship update)
** add fleet id tracker to ship, implement in apply choice
** game_data::apply_choice
*** planet command
*** fleet command
** fixed command incrementation interface, added fleet serialization
** merged draw and data responsibility in selector in client::game

** translate, zoom
** test event handling
    why don't commands show? - translate before rotate!
    why does selection rect draw at odd places? - use e.mouseMove.[x|y]
    why area select when click? - just tiny area select?
    find how to scale command arrow only lengthwise - transform order
** added utility
** client game: choice event return value
** server com: allocate/deallocate packet
** client game: draw command
** client game
*** build choice interface
**** clicked_at
     make a "selectable" class with meta info: id, type etc.
     
     make commands from and to selectables? or just from? just track
     selection? go back to having a "selected" attribute?
**** make_command
** split com into socket_t, com_client, com_server
** replaced client's game_handler with struct client_game
** implemented command serialization
** started writing choice_event handler
** client game
*** area_select
** server game
*** universe construction
**** game settings object
**** solar distribution
** client view dimensions set to match game_data.settings
** client simulation play/pause with space key
** fixed rudementary game_data build routine
** added game settings attributes
** fixed operator <<(packet, solar)
** added solar to drawing
** removed id attributes (stored in has map pair)
** added player to game_data 
** client game_data g0 should update after simulation
   replaced socket_t by socket_t* in query function

   apparently, passing ref(socket_t) (probably its the
   ref(sf::Packet?) to thread causes ~thread() which in turn causes
   abort
** server receives choice
   related to copying packets - fixed by using client_t* instead of
   client_t in queue.  

   gets n=-9744, for some reason still enters push loop. Test run with
   &&res in loop condition. Check if n is wrong from start.
* [old] basic goals
** server game
*** ship interactions
**** structure
***** let ship interactions be governed by interaction functions
***** introduce a ship specific table keyed on [action, t_target]
***** let the ship templates build the interaction function objects
***** interactions require the game data context to be available
***** may need an on-action-setup trigger for e.g. trade routes
***** let ships define a list of valid interactions
***** extension: let researched upgrades extend the interactions
**** list of
***** cargo ship, friendly solar: trade route (resource allocation?)
***** colonizer, neutral solar: colonize
***** fighter, enemy fleet: engage
***** bomber, enemy solar: bombard
*** consider neighbourhood trackers for ships
**** key the ship grid on player
**** look up friendly neighbours for boost interaction
**** look up opponent neighbours for fire interaction
*** fleet actions
**** require that all, some or no ships have some action available
**** available actions are extended by those defined by all ships
**** action complete callback for e.g. resume action after combat
**** also has reaction mode: engage on sight / focus target / flee
***** engage on sight is conditioned on: some fight
**** on interaction, run ship interaction functions if available
**** list of
***** none, friendly solar: land
***** some bombard, enemy solar: bombard
***** none, friendly fleet: join, follow
***** some fight, friendly fleet: guard
***** none, enemy fleet: follow
***** some fight, enemy fleet: engage
*** introduce cargo ships for mining colonies
*** introduce priorities with cost multipliers for ships
*** let ship build be conditioned on research and industry level
*** research structure
**** hash table
**** nodes with:
     requirement list
     cost
     level
     level-dependent modifier functions
     allow list
*** decide what to do with clients without objects
** client game
*** new command gui and target gui
**** target options: based on fleet and ship actions
**** targui defaults (depends on action design)
***** send all if from waypoint
***** send colonizer if command is colonize
***** only show gui if multiple targets
***** don't show self as target
**** command_gui should have option to allocate X ships of type T
*** choice/evolution: display ready players, autoplay when all ready
*** simulation: ?interpolate using ship velocity?
*** draw all ships in same size, have a ship.draw_scale
    so that ships can be drawn in same size in command gui
    but different sizes in universe
*** events board
    messages such as "your fleet was destroyed" or "your solar X
    merged with Bla's solar Y; your population won the ensuing battle"
** before game interface
* [old] long term goals
** strategy
*** different solars have different resources
    specific research projects
    specific production
*** research directions
**** vision
**** stealth
**** espionage
**** propulsion & navigation
**** weapons
**** shields
**** infrastructure
**** democracy
*** diplomatic agreements
**** cease fire
**** peace
**** military alliance
**** trade agreement
** tactics
*** new ships with trigger functions
**** make a solar build queue
***** ship/turret designer interface
***** ship design focus/priority
*** resources on map to match with buildings?
*** old ship model
**** ship components
    construct on grid with structure components? 
    each component has a type, size, energy usage, cost...
**** engine
**** energy
**** shield
**** weapons
**** hull
**** life support
**** cargo hold
**** ship types
***** bombers
     good at bombing solars
     bad at fighting any other ship
***** fighters
     good at fighting battleships
     bad at bombing solars
***** battleships
     good at destroying bombers
     bad at fighting fighters
***** transport
     automatically deployed ship for trade agreements
**** ship experience and fleet commanders
**** add ship rotation speed and ships can only fire forward
** world
*** generate map while exploring
*** define discovered area for players
*** treasures in space
*** terrain types
**** nebula
     damaging area with low sight
     find rare resources
**** high temperospatial curvature
     chance of worm-holes
     low navigation: risk going off course
     small ships risk falling in worm hole
**** asteroids
     slow travel speed
     find resources
     [low shields] risk damage
*** moving solars
*** barbarians
